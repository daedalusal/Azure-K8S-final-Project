---
- name: Basic setup for Kubernetes nodes
  hosts: all
  become: yes
  become_method: sudo
  become_user: root

  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes

    - name: Install required packages
      apt:
        name:
          - curl
          - apt-transport-https
          - ca-certificates
          - gpg
        state: present

    - name: Set hostname for master
      hostname:
        name: k8s-master
      when: "'master' in group_names"

    - name: Set hostname for workers
      hostname:
        name: "k8s-worker-{{ inventory_hostname }}"
      when: "'workers' in group_names"

    - name: Disable swap
      command: swapoff -a

    - name: Remove swap entry from /etc/fstab
      replace:
        path: /etc/fstab
        regexp: '^([^#].*?\sswap\s.*)$'
        replace: '# \1'

    - name: Create keyrings directory for Kubernetes
      file:
        path: /etc/apt/keyrings
        state: directory
        mode: '0755'

    - name: Download Kubernetes APT key (stable version)
      shell: |
        curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
      args:
        creates: /etc/apt/keyrings/kubernetes-apt-keyring.gpg

    - name: Add Kubernetes APT repository (stable version)
      apt_repository:
        repo: "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /"
        state: present
        filename: kubernetes.list

    - name: Install Kubernetes components
      apt:
        name:
          - kubelet
          - kubeadm
          - kubectl
        state: present
        update_cache: yes

    - name: Hold kubelet at current version
      dpkg_selections:
        name: kubelet
        selection: hold

    - name: Hold kubeadm at current version
      dpkg_selections:
        name: kubeadm
        selection: hold

    - name: Hold kubectl at current version
      dpkg_selections:
        name: kubectl
        selection: hold

    - name: Install containerd
      apt:
        name: containerd
        state: present

    - name: Configure containerd
      shell: |
        mkdir -p /etc/containerd
        containerd config default | tee /etc/containerd/config.toml
      args:
        creates: /etc/containerd/config.toml

    - name: Configure containerd to use systemd cgroup driver
      replace:
        path: /etc/containerd/config.toml
        regexp: 'SystemdCgroup = false'
        replace: 'SystemdCgroup = true'

    - name: Restart containerd
      service:
        name: containerd
        state: restarted
        enabled: yes

    - name: Enable net.ipv4.ip_forward
      sysctl:
        name: net.ipv4.ip_forward
        value: '1'
        state: present
        reload: yes

    - name: Load bridge netfilter module
      modprobe:
        name: br_netfilter
        state: present

    - name: Ensure br_netfilter module loads on boot
      lineinfile:
        path: /etc/modules-load.d/k8s.conf
        line: br_netfilter
        create: yes

    - name: Load overlay module for containerd
      modprobe:
        name: overlay
        state: present

    - name: Ensure overlay module loads on boot
      lineinfile:
        path: /etc/modules-load.d/k8s.conf
        line: overlay
        create: yes

    - name: Create sysctl configuration file for Kubernetes
      copy:
        content: |
          net.bridge.bridge-nf-call-iptables  = 1
          net.bridge.bridge-nf-call-ip6tables = 1
          net.ipv4.ip_forward                 = 1
          net.ipv4.conf.all.forwarding        = 1
          net.ipv6.conf.all.forwarding        = 1
        dest: /etc/sysctl.d/k8s.conf
        mode: '0644'

    - name: Apply sysctl settings from k8s.conf
      command: sysctl --system

    - name: Ensure systemd-resolved is configured properly
      lineinfile:
        path: /etc/systemd/resolved.conf
        regexp: '^#?DNS='
        line: 'DNS=168.63.129.16 8.8.8.8'
        state: present
      notify: restart systemd-resolved

    - name: Ensure systemd-resolved fallback DNS
      lineinfile:
        path: /etc/systemd/resolved.conf
        regexp: '^#?FallbackDNS='
        line: 'FallbackDNS=1.1.1.1 8.8.4.4'
        state: present
      notify: restart systemd-resolved

  handlers:
    - name: restart systemd-resolved
      service:
        name: systemd-resolved
        state: restarted

- name: Initialize Kubernetes master and install Calico
  hosts: master
  become: yes
  tasks:
    - name: Initialize the Kubernetes cluster using kubeadm
      command: kubeadm init --pod-network-cidr=192.168.0.0/16
      args:
        creates: /etc/kubernetes/admin.conf
      register: kubeadm_init

    - name: Set up kubeconfig for azureuser
      shell: |
        mkdir -p /home/azureuser/.kube
        cp -f /etc/kubernetes/admin.conf /home/azureuser/.kube/config
        chown azureuser:azureuser /home/azureuser/.kube/config
      args:
        executable: /bin/bash

    - name: Install Calico network plugin
      shell: |
        kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Wait for Calico to be ready
      shell: |
        kubectl wait --for=condition=Ready pod -l k8s-app=calico-node -n kube-system --timeout=300s
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: calico_ready
      retries: 5
      delay: 30
      until: calico_ready.rc == 0

    - name: Wait for Calico API resources to be available
      shell: |
        kubectl get crd felixconfigurations.crd.projectcalico.org
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: felix_crd_check
      retries: 10
      delay: 15
      until: felix_crd_check.rc == 0

    - name: Create default FelixConfiguration if it doesn't exist
      shell: |
        kubectl get felixconfiguration default >/dev/null 2>&1 || kubectl apply -f - <<EOF
        apiVersion: crd.projectcalico.org/v1
        kind: FelixConfiguration
        metadata:
          name: default
        spec:
          natOutgoingEnabled: true
        EOF
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: felix_create
      changed_when: felix_create.stdout.find('created') != -1

    - name: Enable Calico outbound NAT for pod traffic
      shell: |
        kubectl patch felixconfiguration default --type='merge' -p '{"spec":{"natOutgoingEnabled":true}}'
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: calico_nat
      changed_when: calico_nat.rc == 0
      retries: 3
      delay: 10

    - name: Check if default IP pool exists
      shell: |
        kubectl get ippool default-ipv4-ippool || echo "not found"
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: ippool_check
      ignore_errors: yes

    - name: Configure Calico IP pool for Azure
      shell: |
        if [[ "{{ ippool_check.stdout }}" == *"not found"* ]]; then
          kubectl apply -f - <<EOF
        apiVersion: crd.projectcalico.org/v1
        kind: IPPool
        metadata:
          name: default-ipv4-ippool
        spec:
          cidr: 192.168.0.0/16
          ipipMode: Always
          natOutgoing: true
          nodeSelector: all()
        EOF
        else
          kubectl patch ippool default-ipv4-ippool --type='merge' -p '{"spec":{"natOutgoing":true}}'
        fi
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: calico_ippool
      ignore_errors: yes

    - name: Restart Calico pods to apply configuration
      shell: |
        kubectl delete pods -n kube-system -l k8s-app=calico-node
        kubectl delete pods -n kube-system -l k8s-app=calico-kube-controllers
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      when: calico_nat.changed or calico_ippool.changed

    - name: Patch CoreDNS to use Azure DNS with fallback
      shell: |
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: coredns
          namespace: kube-system
        data:
          Corefile: |
            .:53 {
                errors
                health {
                   lameduck 5s
                }
                ready
                kubernetes cluster.local in-addr.arpa ip6.arpa {
                   pods insecure
                   fallthrough in-addr.arpa ip6.arpa
                   ttl 30
                }
                prometheus :9153
                forward . 168.63.129.16 8.8.8.8 1.1.1.1 {
                   max_concurrent 1000
                   policy sequential
                   health_check 5s
                }
                cache 30 {
                   disable success cluster.local
                   disable denial cluster.local
                }
                loop
                reload
                loadbalance
            }
        EOF
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Create jenkins namespace
      shell: |
        kubectl create namespace jenkins || true
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Remove all NetworkPolicies for learning environment
      shell: |
        # Remove any existing NetworkPolicies that might block communication
        kubectl delete networkpolicy --all --all-namespaces || true
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Restart CoreDNS
      shell: kubectl rollout restart deployment coredns -n kube-system
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Verify cluster status after setup
      shell: |
        echo "=== Cluster Info ==="
        kubectl cluster-info
        echo "=== Node Status ==="
        kubectl get nodes -o wide
        echo "=== Pod Status ==="
        kubectl get pods --all-namespaces
        echo "=== DNS Test ==="
        kubectl run dns-test --image=busybox:1.28 --rm -it --restart=Never --command -- nslookup kubernetes.default || true
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: cluster_status
      ignore_errors: yes

    - name: Display cluster status
      debug:
        var: cluster_status.stdout_lines

    - name: Get kubeadm join command
      shell: kubeadm token create --print-join-command
      register: join_command
      changed_when: false

    - name: Set join command fact for workers
      set_fact:
        worker_join_cmd: "{{ join_command.stdout }}"
      delegate_to: localhost
      run_once: true

- name: Join worker nodes to the cluster
  hosts: workers
  become: yes
  tasks:
    - name: Join the node to the cluster
      shell: "{{ hostvars[groups['master'][0]].worker_join_cmd }} --ignore-preflight-errors=all"
      args:
        creates: /etc/kubernetes/kubelet.conf

- name: Deploy Custom Jenkins with Docker Hub Image
  hosts: master
  become: yes
  tasks:
    - name: Ensure jenkins namespace exists
      shell: |
        kubectl get namespace jenkins || kubectl create namespace jenkins
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Deploy Custom Jenkins using Docker Hub image
      shell: |
        cat <<'EOF' | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: custom-jenkins
          namespace: jenkins
          labels:
            app: custom-jenkins
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: custom-jenkins
          template:
            metadata:
              labels:
                app: custom-jenkins
            spec:
              containers:
              - name: jenkins
                image: yourusername/jenkins-azure-dns-fix:latest
                imagePullPolicy: Always
                ports:
                - containerPort: 8080
                  name: http
                - containerPort: 50000
                  name: agent
                env:
                - name: JAVA_OPTS
                  value: "-Djenkins.install.runSetupWizard=false -Dhudson.model.DownloadService.noSignatureCheck=true -Djava.net.preferIPv4Stack=true"
                - name: JENKINS_OPTS
                  value: "--httpPort=8080"
                volumeMounts:
                - name: jenkins-home
                  mountPath: /var/jenkins_home
                resources:
                  requests:
                    memory: "512Mi"
                    cpu: "500m"
                  limits:
                    memory: "2Gi"
                    cpu: "2000m"
                livenessProbe:
                  httpGet:
                    path: /login
                    port: 8080
                  initialDelaySeconds: 60
                  periodSeconds: 30
                readinessProbe:
                  httpGet:
                    path: /login
                    port: 8080
                  initialDelaySeconds: 30
                  periodSeconds: 10
              volumes:
              - name: jenkins-home
                emptyDir: {}
              restartPolicy: Always
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: custom-jenkins
          namespace: jenkins
          labels:
            app: custom-jenkins
        spec:
          selector:
            app: custom-jenkins
          ports:
          - name: http
            port: 8080
            targetPort: 8080
          - name: agent
            port: 50000
            targetPort: 50000
          type: ClusterIP
        ---
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: jenkins-ingress
          namespace: jenkins
          annotations:
            nginx.ingress.kubernetes.io/ssl-redirect: "true"
            nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
            cert-manager.io/cluster-issuer: "letsencrypt-prod"
        spec:
          ingressClassName: nginx
          tls:
          - hosts:
            - jenkins.yourdomain.com
            secretName: jenkins-tls
          rules:
          - host: jenkins.yourdomain.com
            http:
              paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: custom-jenkins
                    port:
                      number: 8080
        EOF
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      args:
        executable: /bin/bash

    - name: Wait for Jenkins deployment to be ready
      shell: |
        kubectl wait --for=condition=Available deployment/custom-jenkins -n jenkins --timeout=300s
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: jenkins_ready
      retries: 3
      delay: 30







    - name: Get Jenkins admin password if deployment succeeded
      shell: |
        if kubectl get secret jenkins -n jenkins >/dev/null 2>&1; then
          echo "Jenkins admin password:"
          kubectl get secret jenkins -n jenkins -o jsonpath="{.data.jenkins-admin-password}" | base64 --decode
          echo ""
          echo "Access Jenkins with: kubectl port-forward svc/jenkins 8080:8080 -n jenkins"
        else
          echo "Jenkins secret not found - deployment may have failed"
        fi
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: jenkins_credentials
      ignore_errors: yes

    - name: Display Jenkins access information
      debug:
        var: jenkins_credentials.stdout_lines

    - name: Configure Jenkins for CI/CD pipeline
      shell: |
        # Create a ConfigMap with Jenkins pipeline configuration
        kubectl apply -f - <<EOF
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: jenkins-pipeline-config
          namespace: jenkins
        data:
          pipeline-job.xml: |
            <?xml version='1.1' encoding='UTF-8'?>
            <flow-definition plugin="workflow-job@2.46">
              <actions/>
              <description>Python REST API CI/CD Pipeline</description>
              <keepDependencies>false</keepDependencies>
              <properties>
                <org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
                  <triggers>
                    <hudson.triggers.SCMTrigger>
                      <spec>H/5 * * * *</spec>
                      <ignorePostCommitHooks>false</ignorePostCommitHooks>
                    </hudson.triggers.SCMTrigger>
                  </triggers>
                </org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
              </properties>
              <definition class="org.jenkinsci.plugins.workflow.cps.CpsScmFlowDefinition" plugin="workflow-cps@2.94">
                <scm class="hudson.plugins.git.GitSCM" plugin="git@4.8.3">
                  <configVersion>2</configVersion>
                  <userRemoteConfigs>
                    <hudson.plugins.git.UserRemoteConfig>
                      <url>https://github.com/your-username/python-rest-api.git</url>
                    </hudson.plugins.git.UserRemoteConfig>
                  </userRemoteConfigs>
                  <branches>
                    <hudson.plugins.git.BranchSpec>
                      <name>*/main</name>
                    </hudson.plugins.git.BranchSpec>
                  </branches>
                  <doGenerateSubmoduleConfigurations>false</doGenerateSubmoduleConfigurations>
                  <submoduleCfg class="list"/>
                  <extensions/>
                </scm>
                <scriptPath>Jenkinsfile</scriptPath>
                <lightweight>true</lightweight>
              </definition>
              <triggers/>
              <disabled>false</disabled>
            </flow-definition>
        EOF
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Create RBAC for Jenkins to manage deployments
      shell: |
        kubectl apply -f - <<EOF
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRole
        metadata:
          name: jenkins-deploy
        rules:
        - apiGroups: [""]
          resources: ["pods", "services", "configmaps", "secrets"]
          verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
        - apiGroups: ["apps"]
          resources: ["deployments", "replicasets"]
          verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
        - apiGroups: ["networking.k8s.io"]
          resources: ["ingresses"]
          verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
        ---
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRoleBinding
        metadata:
          name: jenkins-deploy
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: jenkins-deploy
        subjects:
        - kind: ServiceAccount
          name: jenkins
          namespace: jenkins
        EOF
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

- name: Deploy NGINX ingress controller in Kubernetes using Helm
  hosts: master
  become: yes
  tasks:
    - name: Add NGINX ingress Helm repo
      command: helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Update Helm repos
      command: helm repo update
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Install NGINX ingress controller
      command: >
        helm install ingress-nginx ingress-nginx/ingress-nginx
        --namespace ingress-nginx --create-namespace
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

- name: Install cert-manager in Kubernetes using Helm
  hosts: master
  become: yes
  tasks:
    - name: Add Jetstack Helm repo
      command: helm repo add jetstack https://charts.jetstack.io
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Update Helm repos
      command: helm repo update
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Remove existing cert-manager if present (for clean installation)
      shell: |
        helm uninstall cert-manager --namespace cert-manager || true
        kubectl delete namespace cert-manager || true
        sleep 30
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Install cert-manager (without --wait to avoid hanging)
      command: >
        helm install cert-manager jetstack/cert-manager
        --namespace cert-manager --create-namespace
        --set installCRDs=true
        --set global.leaderElection.namespace=cert-manager
        --timeout=5m
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: cert_manager_install
      retries: 3
      delay: 30
      until: cert_manager_install.rc == 0

    - name: Wait for cert-manager pods to be created
      shell: |
        timeout 300 bash -c 'until kubectl get pods -n cert-manager | grep cert-manager; do sleep 5; done'
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Wait for cert-manager controller to be ready (with timeout)
      shell: |
        kubectl wait --for=condition=Ready pod -l app=cert-manager -n cert-manager --timeout=300s || echo "Timeout waiting for cert-manager controller"
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Wait for cert-manager webhook to be ready (with timeout)
      shell: |
        kubectl wait --for=condition=Ready pod -l app=webhook -n cert-manager --timeout=300s || echo "Timeout waiting for cert-manager webhook"
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Configure cert-manager with Azure DNS
      shell: |
        kubectl patch deployment cert-manager -n cert-manager -p '{
          "spec": {
            "template": {
              "spec": {
                "dnsPolicy": "ClusterFirst",
                "dnsConfig": {
                  "nameservers": ["168.63.129.16", "8.8.8.8"],
                  "searches": ["cert-manager.svc.cluster.local", "svc.cluster.local", "cluster.local"],
                  "options": [
                    {"name": "ndots", "value": "2"},
                    {"name": "edns0"}
                  ]
                }
              }
            }
          }
        }'
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Wait for cert-manager to restart with DNS configuration
      shell: |
        kubectl rollout status deployment/cert-manager -n cert-manager --timeout=300s
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Create ClusterIssuer for Let's Encrypt
      shell: |
        # Wait for webhook to be fully ready, then create ClusterIssuer
        sleep 30
        kubectl apply --validate=false -f - <<EOF
        apiVersion: cert-manager.io/v1
        kind: ClusterIssuer
        metadata:
          name: letsencrypt-prod
        spec:
          acme:
            server: https://acme-v02.api.letsencrypt.org/directory
            email: Klodian.kuka@gmail.com
            privateKeySecretRef:
              name: letsencrypt-prod
            solvers:
            - http01:
                ingress:
                  class: nginx
        EOF
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Create Jenkins Ingress with HTTPS
      shell: |
        kubectl apply -f - <<EOF
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: jenkins-ingress
          namespace: jenkins
          annotations:
            kubernetes.io/ingress.class: "nginx"
            cert-manager.io/cluster-issuer: "letsencrypt-prod"
            nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
            nginx.ingress.kubernetes.io/rewrite-target: /
            # Jenkins-specific annotations
            nginx.ingress.kubernetes.io/proxy-body-size: "50m"
            nginx.ingress.kubernetes.io/proxy-request-buffering: "off"
            nginx.ingress.kubernetes.io/proxy-read-timeout: "300"
            nginx.ingress.kubernetes.io/proxy-send-timeout: "300"
        spec:
          tls:
          - hosts:
            - jenkins.yourdomain.com
            secretName: jenkins-tls
          rules:
          - host: jenkins.yourdomain.com
            http:
              paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: jenkins
                    port:
                      number: 8080
        EOF
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Wait for Jenkins Ingress to be ready
      shell: |
        kubectl wait --for=condition=Ready ingress/jenkins-ingress -n jenkins --timeout=300s
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Display Jenkins access information
      shell: |
        echo "=================================="
        echo "🚀 JENKINS CI/CD PIPELINE READY!"
        echo "=================================="
        echo ""
        echo "📍 Access Jenkins at:"
        echo "   HTTPS: https://jenkins.yourdomain.com"
        echo "   (Automatic TLS certificate from Let's Encrypt)"
        echo ""
        echo "🔑 Get Jenkins admin password:"
        echo "   kubectl get secret jenkins -n jenkins -o jsonpath='{.data.jenkins-admin-password}' | base64 -d"
        echo ""
        echo "⚠️  IMPORTANT: Configure DNS first!"
        echo "   Add A record: jenkins.yourdomain.com → {{ ansible_default_ipv4.address }}"
        echo ""
        echo "✅ Features enabled:"
        echo "   - NGINX Ingress Controller"
        echo "   - cert-manager with Let's Encrypt"
        echo "   - Automatic HTTPS certificates"
        echo "   - Jenkins with Kubernetes agents"
        echo ""
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

