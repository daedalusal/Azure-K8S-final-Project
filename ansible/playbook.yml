---
- name: Basic setup for Kubernetes nodes
  hosts: all
  become: yes
  become_method: sudo
  become_user: root
  vars:
    jenkins_domain: "jenkins.daedalusproject.online"
    base_domain: "daedalusproject.online"

  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes

    - name: Install required packages
      apt:
        name:
          - curl
          - apt-transport-https
          - ca-certificates
          - gpg
        state: present

    - name: Set hostname for master
      hostname:
        name: k8s-master
      when: "'master' in group_names"

    - name: Set hostname for workers
      hostname:
        name: "k8s-worker-{{ inventory_hostname }}"
      when: "'workers' in group_names"

    - name: Disable swap
      command: swapoff -a

    - name: Remove swap entry from /etc/fstab
      replace:
        path: /etc/fstab
        regexp: '^([^#].*?\sswap\s.*)$'
        replace: '# \1'

    - name: Create keyrings directory for Kubernetes
      file:
        path: /etc/apt/keyrings
        state: directory
        mode: '0755'

    - name: Download Kubernetes APT key (stable version)
      shell: |
        curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
      args:
        creates: /etc/apt/keyrings/kubernetes-apt-keyring.gpg

    - name: Add Kubernetes APT repository (stable version)
      apt_repository:
        repo: "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /"
        state: present
        filename: kubernetes.list

    - name: Install Kubernetes components
      apt:
        name:
          - kubelet
          - kubeadm
          - kubectl
        state: present
        update_cache: yes

    - name: Hold kubelet at current version
      dpkg_selections:
        name: kubelet
        selection: hold

    - name: Hold kubeadm at current version
      dpkg_selections:
        name: kubeadm
        selection: hold

    - name: Hold kubectl at current version
      dpkg_selections:
        name: kubectl
        selection: hold

    - name: Install containerd
      apt:
        name: containerd
        state: present

    - name: Configure containerd
      shell: |
        mkdir -p /etc/containerd
        containerd config default | tee /etc/containerd/config.toml
      args:
        creates: /etc/containerd/config.toml

    - name: Configure containerd to use systemd cgroup driver
      replace:
        path: /etc/containerd/config.toml
        regexp: 'SystemdCgroup = false'
        replace: 'SystemdCgroup = true'

    - name: Restart containerd
      service:
        name: containerd
        state: restarted
        enabled: yes

    - name: Enable net.ipv4.ip_forward
      sysctl:
        name: net.ipv4.ip_forward
        value: '1'
        state: present
        reload: yes

    - name: Load bridge netfilter module
      modprobe:
        name: br_netfilter
        state: present

    - name: Ensure br_netfilter module loads on boot
      lineinfile:
        path: /etc/modules-load.d/k8s.conf
        line: br_netfilter
        create: yes

    - name: Load overlay module for containerd
      modprobe:
        name: overlay
        state: present

    - name: Ensure overlay module loads on boot
      lineinfile:
        path: /etc/modules-load.d/k8s.conf
        line: overlay
        create: yes

    - name: Create sysctl configuration file for Kubernetes
      copy:
        content: |
          net.bridge.bridge-nf-call-iptables  = 1
          net.bridge.bridge-nf-call-ip6tables = 1
          net.ipv4.ip_forward                 = 1
          net.ipv4.conf.all.forwarding        = 1
          net.ipv6.conf.all.forwarding        = 1
        dest: /etc/sysctl.d/k8s.conf
        mode: '0644'

    - name: Apply sysctl settings from k8s.conf
      command: sysctl --system

  handlers:

- name: Initialize Kubernetes master and install Calico
  hosts: master
  become: yes
  vars:
    jenkins_domain: "jenkins.daedalusproject.online"
    base_domain: "daedalusproject.online"
  tasks:
    - name: Initialize the Kubernetes cluster using kubeadm
      command: kubeadm init --pod-network-cidr=192.168.0.0/16
      args:
        creates: /etc/kubernetes/admin.conf
      register: kubeadm_init

    - name: Set up kubeconfig for azureuser
      shell: |
        mkdir -p /home/azureuser/.kube
        cp -f /etc/kubernetes/admin.conf /home/azureuser/.kube/config
        chown azureuser:azureuser /home/azureuser/.kube/config
      args:
        executable: /bin/bash

    - name: Install Calico network plugin
      shell: |
        kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Wait for Calico to be ready
      shell: |
        kubectl wait --for=condition=Ready pod -l k8s-app=calico-node -n kube-system --timeout=300s
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: calico_ready
      retries: 5
      delay: 30
      until: calico_ready.rc == 0

    - name: Wait for Calico API resources to be available
      shell: |
        kubectl get crd felixconfigurations.crd.projectcalico.org
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: felix_crd_check
      retries: 10
      delay: 15
      until: felix_crd_check.rc == 0

    - name: Create default FelixConfiguration if it doesn't exist
      shell: |
        kubectl get felixconfiguration default >/dev/null 2>&1 || kubectl apply -f - <<EOF
        apiVersion: crd.projectcalico.org/v1
        kind: FelixConfiguration
        metadata:
          name: default
        spec:
          natOutgoingEnabled: true
        EOF
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: felix_create
      changed_when: felix_create.stdout.find('created') != -1

    - name: Enable Calico outbound NAT for pod traffic
      shell: |
        kubectl patch felixconfiguration default --type='merge' -p '{"spec":{"natOutgoingEnabled":true}}'
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: calico_nat
      changed_when: calico_nat.rc == 0
      retries: 3
      delay: 10

    - name: Check if default IP pool exists
      shell: |
        kubectl get ippool default-ipv4-ippool || echo "not found"
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: ippool_check
      ignore_errors: yes

    - name: Configure Calico IP pool for Azure
      shell: |
        if [[ "{{ ippool_check.stdout }}" == *"not found"* ]]; then
          kubectl apply -f - <<EOF
        apiVersion: crd.projectcalico.org/v1
        kind: IPPool
        metadata:
          name: default-ipv4-ippool
        spec:
          cidr: 192.168.0.0/16
          vxlanMode: Always
          natOutgoing: true
          nodeSelector: all()
        EOF
        else
          kubectl patch ippool default-ipv4-ippool --type='merge' -p '{"spec":{"vxlanMode":"Always","natOutgoing":true}}'
        fi
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: calico_ippool
      ignore_errors: yes

    - name: Configure Calico to use VXLAN mode for Azure
      shell: |
        # Enable VXLAN mode in Felix configuration
        kubectl patch felixconfiguration default --type='merge' -p '{
          "spec": {
            "vxlanEnabled": true,
            "ipipEnabled": false,
            "natOutgoingEnabled": true
          }
        }'
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: calico_vxlan
      ignore_errors: yes

    - name: Restart Calico pods to apply configuration
      shell: |
        kubectl delete pods -n kube-system -l k8s-app=calico-node
        kubectl delete pods -n kube-system -l k8s-app=calico-kube-controllers
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      when: calico_nat.changed or calico_ippool.changed or calico_vxlan.changed

    - name: Verify Calico VXLAN configuration
      shell: |
        echo "=== Calico Configuration Status ==="
        echo "Felix Configuration:"
        kubectl get felixconfiguration default -o yaml | grep -E "(vxlanEnabled|ipipEnabled|natOutgoingEnabled)" || echo "No Felix config found"
        echo ""
        echo "IP Pool Configuration:"
        kubectl get ippool default-ipv4-ippool -o yaml | grep -E "(vxlanMode|ipipMode|natOutgoing)" || echo "No IP pool found"
        echo ""
        echo "Calico Node Status:"
        kubectl get pods -n kube-system -l k8s-app=calico-node -o wide
        echo ""
        echo "To verify VXLAN interfaces manually, run on nodes:"
        echo "ip link show type vxlan"
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: calico_verification
      ignore_errors: yes

    - name: Display Calico verification results
      debug:
        var: calico_verification.stdout_lines



    - name: Create jenkins namespace
      shell: |
        kubectl create namespace jenkins || true
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Remove all NetworkPolicies for learning environment
      shell: |
        # Remove any existing NetworkPolicies that might block communication
        kubectl delete networkpolicy --all --all-namespaces || true
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes



    - name: Verify cluster status after setup
      shell: |
        echo "=== Cluster Info ==="
        kubectl cluster-info
        echo "=== Node Status ==="
        kubectl get nodes -o wide
        echo "=== Pod Status ==="
        kubectl get pods --all-namespaces
        echo "=== DNS Test ==="
        kubectl run dns-test --image=busybox:1.28 --rm -it --restart=Never --command -- nslookup kubernetes.default || true
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: cluster_status
      ignore_errors: yes

    - name: Display cluster status
      debug:
        var: cluster_status.stdout_lines

    - name: Get kubeadm join command
      shell: kubeadm token create --print-join-command
      register: join_command
      changed_when: false

    - name: Set join command fact for workers
      set_fact:
        worker_join_cmd: "{{ join_command.stdout }}"
      delegate_to: localhost
      run_once: true

- name: Join worker nodes to the cluster
  hosts: workers
  become: yes
  vars:
    jenkins_domain: "jenkins.daedalusproject.online"
    base_domain: "daedalusproject.online"
  tasks:
    - name: Join the node to the cluster
      shell: "{{ hostvars[groups['master'][0]].worker_join_cmd }} --ignore-preflight-errors=all"
      args:
        creates: /etc/kubernetes/kubelet.conf

- name: Install Helm and Jenkins using Helm chart
  hosts: master
  become: yes
  vars:
    jenkins_domain: "jenkins.daedalusproject.online"
    base_domain: "daedalusproject.online"
  tasks:
    - name: Download Helm installation script
      get_url:
        url: https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        dest: /tmp/get_helm.sh
        mode: '0700'

    - name: Install Helm
      shell: /tmp/get_helm.sh
      args:
        creates: /usr/local/bin/helm

    - name: Add Jenkins Helm repo
      command: helm repo add jenkins https://charts.jenkins.io
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Update Helm repos
      command: helm repo update
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Remove existing Jenkins installation if present
      shell: |
        helm uninstall jenkins --namespace jenkins || true
        kubectl delete namespace jenkins --wait=true || true
        kubectl delete pv --all || true
        kubectl delete pvc --all -n jenkins || true
        sleep 60
        kubectl create namespace jenkins || true
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Install Jenkins using Helm chart
      command: >
        helm install jenkins jenkins/jenkins
        --namespace jenkins
        --set controller.serviceType=ClusterIP
        --set persistence.enabled=false
        --set controller.resources.requests.memory=512Mi
        --set controller.resources.requests.cpu=500m
        --set controller.javaOpts="-Xmx512m"
        --set controller.initContainerResources.requests.memory=256Mi
        --set controller.initContainerResources.requests.cpu=250m
        --set controller.installPlugins=null
        --set controller.sidecars.configAutoReload.enabled=false
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Wait for Jenkins deployment to be ready
      shell: |
        echo "Waiting for Jenkins pods..."
        kubectl get pods -n jenkins
        echo ""
        echo "Checking Jenkins pod events..."
        kubectl describe pod jenkins-0 -n jenkins | tail -20
        echo ""
        echo "Waiting for pod to be ready (with extended timeout)..."
        kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=jenkins -n jenkins --timeout=600s
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: jenkins_ready
      retries: 2
      delay: 60
      ignore_errors: yes

    - name: Troubleshoot Jenkins if not ready
      shell: |
        echo "=== Jenkins Troubleshooting ==="
        echo "Pod Status:"
        kubectl get pods -n jenkins -o wide
        echo ""
        echo "Pod Events:"
        kubectl describe pod jenkins-0 -n jenkins | grep -A 20 "Events:"
        echo ""
        echo "Init Container Logs:"
        kubectl logs jenkins-0 -n jenkins -c init || echo "No init logs available"
        echo ""
        echo "Jenkins Container Logs:"
        kubectl logs jenkins-0 -n jenkins -c jenkins || echo "No jenkins logs available"
        echo ""
        echo "Network connectivity test from pod:"
        kubectl exec jenkins-0 -n jenkins -c init -- nslookup google.com || echo "DNS test failed"
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      when: jenkins_ready.failed
      ignore_errors: yes
      register: jenkins_debug

    - name: Display Jenkins debug information
      debug:
        var: jenkins_debug.stdout_lines
      when: jenkins_ready.failed

- name: Configure Jenkins with essential CI/CD tools
  hosts: master
  become: yes
  vars:
    jenkins_domain: "jenkins.daedalusproject.online"
    base_domain: "daedalusproject.online"
  tasks:
    - name: Wait for Jenkins to be fully ready
      shell: |
        kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=jenkins -n jenkins --timeout=300s
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Install essential tools in Jenkins pod
      shell: |
        echo "=== Installing CI/CD tools in Jenkins ==="
        
        # Install Docker CLI
        kubectl exec jenkins-0 -n jenkins -- sh -c "
          apt-get update -qq &&
          apt-get install -y curl python3 python3-pip &&
          curl -fsSL https://download.docker.com/linux/static/stable/x86_64/docker-20.10.24.tgz | tar xz &&
          mv docker/docker /usr/local/bin/ &&
          chmod +x /usr/local/bin/docker &&
          rm -rf docker
        " || echo "Tool installation failed"
        
        # Install kubectl
        kubectl exec jenkins-0 -n jenkins -- sh -c "
          curl -LO 'https://dl.k8s.io/release/v1.30.0/bin/linux/amd64/kubectl' &&
          chmod +x kubectl &&
          mv kubectl /usr/local/bin/
        " || echo "kubectl installation failed"
        
        echo "=== Tools installed successfully ==="
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Configure Jenkins Kubernetes access
      shell: |
        # Setup kubeconfig
        kubectl exec jenkins-0 -n jenkins -- mkdir -p /var/jenkins_home/.kube || true
        kubectl cp /home/azureuser/.kube/config jenkins/jenkins-0:/var/jenkins_home/.kube/config || true
        kubectl exec jenkins-0 -n jenkins -- chown -R jenkins:jenkins /var/jenkins_home/.kube || true
        
        # Create python-api namespace
        kubectl create namespace python-api || echo "Namespace exists"
        
        # Create basic python deployment for testing
        kubectl apply -f - <<EOF || true
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: python-rest-api
          namespace: python-api
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: python-rest-api
          template:
            metadata:
              labels:
                app: python-rest-api
            spec:
              containers:
              - name: python-rest-api
                image: python:3.9-slim
                command: ["python3", "-c", "import http.server; import socketserver; socketserver.TCPServer(('', 5000), http.server.SimpleHTTPRequestHandler).serve_forever()"]
                ports:
                - containerPort: 5000
        EOF
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Verify Jenkins tool installation
      shell: |
        echo "=== Jenkins Tool Verification ==="
        kubectl exec jenkins-0 -n jenkins -- docker --version || echo "âŒ Docker CLI not available"
        kubectl exec jenkins-0 -n jenkins -- kubectl version --client || echo "âŒ kubectl not available"
        kubectl exec jenkins-0 -n jenkins -- python3 --version || echo "âŒ Python3 not available"
        echo "âœ… Jenkins configuration completed!"
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

- name: Deploy NGINX ingress controller in Kubernetes using Helm
  hosts: master
  become: yes
  vars:
    jenkins_domain: "jenkins.daedalusproject.online"
    base_domain: "daedalusproject.online"
  tasks:
    - name: Add NGINX ingress Helm repo
      command: helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Update Helm repos
      command: helm repo update
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Install NGINX ingress controller
      command: >
        helm install ingress-nginx ingress-nginx/ingress-nginx
        --namespace ingress-nginx --create-namespace
        --set controller.service.type=NodePort
        --set controller.service.nodePorts.http=30080
        --set controller.service.nodePorts.https=30443
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

- name: Install cert-manager in Kubernetes using Helm
  hosts: master
  become: yes
  vars:
    jenkins_domain: "jenkins.daedalusproject.online"
    base_domain: "daedalusproject.online"
  tasks:
    - name: Add Jetstack Helm repo
      command: helm repo add jetstack https://charts.jetstack.io
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Update Helm repos
      command: helm repo update
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Remove existing cert-manager if present (for clean installation)
      shell: |
        helm uninstall cert-manager --namespace cert-manager || true
        kubectl delete namespace cert-manager || true
        sleep 30
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Install cert-manager (without --wait to avoid hanging)
      command: >
        helm install cert-manager jetstack/cert-manager
        --namespace cert-manager --create-namespace
        --set installCRDs=true
        --set global.leaderElection.namespace=cert-manager
        --timeout=5m
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      register: cert_manager_install
      retries: 3
      delay: 30
      until: cert_manager_install.rc == 0

    - name: Wait for cert-manager pods to be created
      shell: |
        timeout 300 bash -c 'until kubectl get pods -n cert-manager | grep cert-manager; do sleep 5; done'
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Wait for cert-manager controller to be ready (with timeout)
      shell: |
        kubectl wait --for=condition=Ready pod -l app=cert-manager -n cert-manager --timeout=300s || echo "Timeout waiting for cert-manager controller"
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Wait for cert-manager webhook to be ready (with timeout)
      shell: |
        kubectl wait --for=condition=Ready pod -l app=webhook -n cert-manager --timeout=300s || echo "Timeout waiting for cert-manager webhook"
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes



    - name: Wait for cert-manager to restart with DNS configuration
      shell: |
        kubectl rollout status deployment/cert-manager -n cert-manager --timeout=300s
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Create ClusterIssuer for Let's Encrypt
      shell: |
        # Wait for webhook to be fully ready, then create ClusterIssuer
        sleep 30
        kubectl apply --validate=false -f - <<EOF
        apiVersion: cert-manager.io/v1
        kind: ClusterIssuer
        metadata:
          name: letsencrypt-prod
        spec:
          acme:
            server: https://acme-v02.api.letsencrypt.org/directory
            email: Klodian.kuka@gmail.com
            privateKeySecretRef:
              name: letsencrypt-prod
            solvers:
            - http01:
                ingress:
                  class: nginx
        EOF
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Create Jenkins Ingress with HTTPS
      shell: |
        kubectl apply -f - <<EOF
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: jenkins-ingress
          namespace: jenkins
          annotations:
            kubernetes.io/ingress.class: "nginx"
            cert-manager.io/cluster-issuer: "letsencrypt-prod"
            nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
            nginx.ingress.kubernetes.io/rewrite-target: /
            # Jenkins-specific annotations
            nginx.ingress.kubernetes.io/proxy-body-size: "50m"
            nginx.ingress.kubernetes.io/proxy-request-buffering: "off"
            nginx.ingress.kubernetes.io/proxy-read-timeout: "300"
            nginx.ingress.kubernetes.io/proxy-send-timeout: "300"
        spec:
          tls:
          - hosts:
            - "{{ jenkins_domain }}"
            secretName: jenkins-tls
          rules:
          - host: "{{ jenkins_domain }}"
            http:
              paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: jenkins
                    port:
                      number: 8080
        EOF
      environment:
        KUBECONFIG: /home/azureuser/.kube/config

    - name: Wait for Jenkins Ingress to be ready
      shell: |
        kubectl wait --for=condition=Ready ingress/jenkins-ingress -n jenkins --timeout=120s || echo "Ingress not ready yet, continuing..."
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

    - name: Display Jenkins access information
      shell: |
        echo "=================================="
        echo "ðŸš€ JENKINS CI/CD PIPELINE READY!"
        echo "=================================="
        echo ""
        echo "ðŸ“ Access Jenkins at:"
        echo "   HTTPS: https://{{ jenkins_domain }}"
        echo "   (Automatic TLS certificate from Let's Encrypt)"
        echo ""
        echo "ðŸ”‘ Get Jenkins admin password:"
        echo "   kubectl get secret jenkins -n jenkins -o jsonpath='{.data.jenkins-admin-password}' | base64 -d"
        echo ""
        echo "âš ï¸  IMPORTANT: Configure DNS first!"
        echo "   Add A record: {{ jenkins_domain }} â†’ {{ ansible_default_ipv4.address }}"
        echo ""
        echo "âœ… Features enabled:"
        echo "   - NGINX Ingress Controller"
        echo "   - cert-manager with Let's Encrypt"
        echo "   - Automatic HTTPS certificates"
        echo "   - Jenkins with Kubernetes agents"
        echo ""
      environment:
        KUBECONFIG: /home/azureuser/.kube/config
      ignore_errors: yes

